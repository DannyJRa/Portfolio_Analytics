---
title: "Untitled"
output: html_document
---


SOURCE: https://www.kaggle.com/karlcottenie/introduction-to-machine-learning-in-r-tutorial

Step 0. Time the code¶
To determine how fast the code runs, copy-past only the R code, highlight the code from this line all the way to the "running_time_tidy" statement, and execute the code.

```{r}

start_time_tidy = proc.time()

```

Step 1. Load in the data.
```{r}

library(tidyverse)

```

# library(reshape2)
# We don't need this in the tidyverse approach
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 2.2.1.9000     ✔ purrr   0.2.4     
✔ tibble  1.3.4          ✔ dplyr   0.7.4     
✔ tidyr   0.7.2          ✔ stringr 1.2.0     
✔ readr   1.1.1.9000     ✔ forcats 0.2.0     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

```{r}


housing.tidy = read_csv('../input/housing.csv')
```

Parsed with column specification:
cols(
  longitude = col_double(),
  latitude = col_double(),
  housing_median_age = col_double(),
  total_rooms = col_double(),
  total_bedrooms = col_double(),
  population = col_double(),
  households = col_double(),
  median_income = col_double(),
  median_house_value = col_double(),
  ocean_proximity = col_character()
)
First thing I always do is use the head command to make sure the data isn't weird and looks how I expected.
```{r}
head(housing.tidy) 


```

# KC: but not really necessary, bc you can just double click on name
# and a tibble automatically prints information similar to the "head" function

```{r}

housing.tidy
# par(mfrow=c(2,5))
# KC: I don't think par influences ggplot statements
# colnames(housing)
# KC: not really needed in tidyverse
# housing will give you all the column names
# piping will recognize the column names anyway
```

                      
                                      


```{r}

housing.tidy %>% gather(longitude:median_house_value, key = "variable", value = "value") %>%
  ggplot(aes(x = value)) + 
  geom_histogram(bins = 30) + facet_wrap(~ variable, scales = 'free_x')

```

Warning message:
“Removed 207 rows containing non-finite values (stat_bin).”

The difference with "melt" seems to be that it has some default statements, which should be specified in gather.

housing.tidy %>% ggplot(aes(x = ocean_proximity)) +
  geom_bar() # KC: missing from Housing_R.r

Step 2. Clean the data
Impute missing values

```{r}

housing.tidy %>% mutate(total_bedrooms_c = ifelse(is.na(total_bedrooms), 
                                                  median(total_bedrooms, na.rm = T),
                                                  total_bedrooms)) %>%
  summary()

```

# KC: this is just to show how I would check whether it did it correctly

Fix the total columns - make them means
```{r}

housing.tidy = housing.tidy %>% 
  mutate(total_bedrooms = ifelse(is.na(total_bedrooms), 
                                 median(total_bedrooms, na.rm = T),
                                 total_bedrooms),
         mean_bedrooms = total_bedrooms/households,
         mean_rooms = total_rooms/households) %>%
  select(-c(total_rooms, total_bedrooms))
head(housing.tidy)

```
                                                       



Turn categoricals into booleans
Lots of code in the original version. I replaced it with the model.matrix function, and then added some code to make sure that the variable names were consistent.

```{r}

cat_housing.tidy = housing.tidy %>% 
  model.matrix( ~ ocean_proximity - 1, data = .) %>%
  as.tibble()
names(cat_housing.tidy) = names(cat_housing.tidy) %>% 
  strsplit("ocean_proximity") %>% map_chr(function(x) x[2])
# KC: this would be a second option, using a very general approach
categories = unique(housing.tidy$ocean_proximity) # all categories
cat_housing.tidy = categories %>% # compare the full vector against each category consecutively
  lapply(function(x) as.numeric(housing.tidy$ocean_proximity == x)) %>% # convert to numeric
  do.call("cbind", .) %>% as.tibble() # clean up
colnames(cat_housing.tidy) = categories # make nice column names
head(cat_housing.tidy)

```


Scale the numerical variables and merge them in one data frame.
This is were tidyverse really shines, I think.

```{r}
cleaned_housing.tidy = housing.tidy %>% 
  select(-c(ocean_proximity, median_house_value)) %>%
  scale() %>% as.tibble() %>%
  bind_cols(cat_housing.tidy) %>%
  add_column(median_house_value = housing.tidy$median_house_value)
cleaned_housing.tidy %>% summary()
# just to check that means etc are the same


```


End the timing of the code
It seems to be 3x as fast on my computer.


```{r}

running_time_tidy = proc.time() - start_time_tidy
running_time_tidy

```

